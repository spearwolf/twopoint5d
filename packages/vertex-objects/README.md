# vertex-objects

![creative-coding](https://img.shields.io/badge/creative-coding-red) ![game-dev](https://img.shields.io/badge/game-dev-green) ![demoOrDie](https://img.shields.io/badge/demo-or_die-blue)

is a typescript library that allows you to create and render multiple and (optionally) instanced geometries with just a single draw call.
such _vertex objects_ are defined by a descriptor &mdash; for creation and usage there is a super easy and oddly satisfying to use object-based api.

it's based on the fantastic [three.js](https://threejs.org/) library which itself is build upon _WebGL_.

the main features of this library are centered around the definition, creation and life-cycle management of _vertex objects_,
in addition there are some more helpers and classes to ease the texture handling, respectively the loading of texture-atlas definitions.

> IMPORTANT: this library is a kind of _meta_ library. there is nothing in this library that three.js doesn't already allow you to do out of the box: however, this library gives you highly specialized tools that allow you to work with complex particle-like and instanced geometries in a super elegant way. a whole bunch of unnecessary boilerplate code is taken away from you and you can concentrate on the creative part of shader development :rocket:

## Vertex Objects

are like particles or freestyle [sprites](https://en.wikipedia.org/wiki/Sprite_(computer_graphics)) whose attributes, vertex and fragment shaders are ~~left to you~~ completely freely definable &mdash; but the management and organization of the underlying geometry data attribute typed array buffers is taken away from you

examples can be found here:
- [animated-billboards](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/animated-billboards.html)
- [animated-sprites](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/animated-sprites.html)
- [instanced-quads](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/instanced-quads.html)
- [crosses](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/crosses.html)
- [textured-quads-from-tileset](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/textured-quads-from-tileset.html)
- [textured-quads](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/textured-quads.html)
- [textured-sprites](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/textured-sprites.html)

> all (most) of these examples are showing _lots of_ sprites in 3d space with just _one webgl draw_ call!

> many of these examples define unusual and quirky properties, but this is intentional and purely for demonstration purposes ;-)


## Texture Mapping

those who work with 2D-, 2.5D ~sprites, tiles or billboard particles will quickly realize that an easy way to import [spritesheet images and texture-atlas definitions](https://en.wikipedia.org/wiki/Texture_atlas) could be very handy.
this library provides helpers for importing tilesets via grid-aligned spritesheet images or texture altases from json files (generated by tools such as [TexturePacker](https://www.codeandweb.com/texturepacker)).

examples can be found here:
- [animated-billboards](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/animated-billboards.html)
- [animated-sprites](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/animated-sprites.html)
- [textured-quads-from-tileset](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/textured-quads-from-tileset.html)
- [textured-sprites](https://github.com/spearwolf/three-vertex-objects/tree/main/examples/textured-sprites.html)


## CHEAT SHEET

### Vertex Object Descriptors

#### Describe your vertex objects

```js
{
    vertexCount: 4,
    indices: [0, 1, 2, 0, 2, 3],        // [optional]

    meshCount: 1,                       // for instanced attributes (use instead of vertexCount)
                                        // not yet fully thought through: VertexBufferObject <- capacity <- meshCount > 1 ?
    attributes: {
        position: {                                     // attribute name
            components: ['x', 'y', 'z'],                // either define components ..
            size: 3,                                    // .. or set number of anonymous components

            type: 'float32',                            // [optional] the default type is float32
            normalized: boolean,                        // [optional] default is not

            usage: 'static' | 'dynamic' | 'stream',     // [optional] default is 'static'
            autoTouch: true                             // [optional] if usage == 'static' then default is false otherwise true
         }
    }

    basePrototpe: class MyBaseClass {};  // [optional]

    methods: {                           // [optional] also works as mixins
        [methodName]() {}
    }
}
```

#### API Overview

```js
const geometry = new VertexObjectGeometry(descriptor, CAPACITY = 1);

const geometry = new InstancedVertexObjectGeometry(instancedDescriptor, INSTANCED_CAPACITY, baseDescriptor, BASE_CAPACITY = 1);
const geometry = new InstancedVertexObjectGeometry(instancedDescriptor, INSTANCED_CAPACITY, baseBufferGeometry);

const vo = geometry.pool.createVO()  // VertexObjectGeometry

const vo = geometry.basePool.createVO()       // InstancedVertexObjectGeometry
const vo = geometry.instancedPool.createVO()

vo.setPosition([...])
vo.x0_0
vo.x1_0
vo.x3_0
vo.x0_1

vo.copy(vo)

geometry.pool.freeVO(vo)
geometry.basePool.freeVO(vo)
geometry.instancedPool.freeVO(vo)

geometry.touchAttributes('position', 'foo')
geometry.touchBuffers({dynamic: false, stream: true, static: false})
geometry.touch('position', {dynamic: true}, ...)  // yes, you can mix it here if you want

geometry.update()  // automatically called by VertexObjects
```

#### Simple Usage

```js
const mesh = new VertexObjects(geometry, material)

mesh.frustumCalled = false  // not needed, but can be very helpful ;)

scene.add(mesh)
```
